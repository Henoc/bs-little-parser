// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var Char        = require("bs-platform/lib/js/char.js");
var List        = require("bs-platform/lib/js/list.js");
var Block       = require("bs-platform/lib/js/block.js");
var Curry       = require("bs-platform/lib/js/curry.js");
var $$String    = require("bs-platform/lib/js/string.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");

function parse(input, parser) {
  return Curry._1(parser, input);
}

function andThen(p, q, input) {
  var match = Curry._1(p, input);
  if (match.tag) {
    return /* ParseFailure */Block.__(1, [
              match[0],
              match[1]
            ]);
  } else {
    var match$1 = Curry._1(q, match[1]);
    if (match$1.tag) {
      return /* ParseFailure */Block.__(1, [
                match$1[0],
                match$1[1]
              ]);
    } else {
      return /* ParseSuccess */Block.__(0, [
                /* tuple */[
                  match[0],
                  match$1[0]
                ],
                match$1[1]
              ]);
    }
  }
}

function $less$star$great(p, q) {
  return (function (param) {
      return andThen(p, q, param);
    });
}

function onlyLeft(p, q, input) {
  var match = Curry._1(p, input);
  if (match.tag) {
    return /* ParseFailure */Block.__(1, [
              match[0],
              match[1]
            ]);
  } else {
    var match$1 = Curry._1(q, match[1]);
    if (match$1.tag) {
      return /* ParseFailure */Block.__(1, [
                match$1[0],
                match$1[1]
              ]);
    } else {
      return /* ParseSuccess */Block.__(0, [
                match[0],
                match$1[1]
              ]);
    }
  }
}

function $less$star(p, q) {
  return (function (param) {
      return onlyLeft(p, q, param);
    });
}

function onlyRight(p, q, input) {
  var match = Curry._1(p, input);
  if (match.tag) {
    return /* ParseFailure */Block.__(1, [
              match[0],
              match[1]
            ]);
  } else {
    var match$1 = Curry._1(q, match[1]);
    if (match$1.tag) {
      return /* ParseFailure */Block.__(1, [
                match$1[0],
                match$1[1]
              ]);
    } else {
      return /* ParseSuccess */Block.__(0, [
                match$1[0],
                match$1[1]
              ]);
    }
  }
}

function $star$great(p, q) {
  return (function (param) {
      return onlyRight(p, q, param);
    });
}

function orElse(p, q, input) {
  var match = Curry._1(p, input);
  if (match.tag) {
    return Curry._1(q, input);
  } else {
    return /* ParseSuccess */Block.__(0, [
              match[0],
              match[1]
            ]);
  }
}

function $less$pipe$great(p, q) {
  return (function (param) {
      return orElse(p, q, param);
    });
}

function rep(p, input) {
  var loop = function (_acc, _input) {
    while(true) {
      var input = _input;
      var acc = _acc;
      var match = Curry._1(p, input);
      if (match.tag) {
        return /* tuple */[
                List.rev(acc),
                input
              ];
      } else {
        _input = match[1];
        _acc = /* :: */[
          match[0],
          acc
        ];
        continue ;
        
      }
    };
  };
  var match = loop(/* [] */0, input);
  return /* ParseSuccess */Block.__(0, [
            match[0],
            match[1]
          ]);
}

function rep1(p) {
  return (function (param) {
      return andThen(p, (function (param) {
                    return rep(p, param);
                  }), param);
    });
}

function optional(p, input) {
  var match = Curry._1(p, input);
  if (match.tag) {
    return /* ParseSuccess */Block.__(0, [
              /* None */0,
              input
            ]);
  } else {
    return /* ParseSuccess */Block.__(0, [
              /* Some */[match[0]],
              match[1]
            ]);
  }
}

function opt(p) {
  return (function (param) {
      return optional(p, param);
    });
}

function andPred(p, input) {
  var others = Curry._1(p, input);
  if (others.tag) {
    return others;
  } else {
    return /* ParseSuccess */Block.__(0, [
              others[0],
              input
            ]);
  }
}

function notPred(p, input) {
  var match = Curry._1(p, input);
  if (match.tag) {
    return /* ParseSuccess */Block.__(0, [
              /* None */0,
              input
            ]);
  } else {
    return /* ParseFailure */Block.__(1, [
              "notPred failure",
              match[1]
            ]);
  }
}

function into(p, fnq, input) {
  var others = Curry._1(p, input);
  if (others.tag) {
    return others;
  } else {
    return Curry._2(fnq, others[0], others[1]);
  }
}

function $great$great(p, fnq) {
  return (function (param) {
      return into(p, fnq, param);
    });
}

function skipWhitespace(whitepspace, input) {
  var listChar = function (str) {
    if (str === "") {
      return /* [] */0;
    } else {
      return /* :: */[
              Caml_string.get(str, 0),
              listChar($$String.sub(str, 1, str.length - 1 | 0))
            ];
    }
  };
  var spaceChars = listChar(whitepspace);
  var contain = function (chr, _charList) {
    while(true) {
      var charList = _charList;
      if (charList) {
        if (chr === charList[0]) {
          return /* true */1;
        } else {
          _charList = charList[1];
          continue ;
          
        }
      } else {
        return /* false */0;
      }
    };
  };
  var _input = input;
  while(true) {
    var input$1 = _input;
    if (input$1[/* text */0].length <= input$1[/* index */1]) {
      return input$1;
    } else if (contain(Caml_string.get(input$1[/* text */0], input$1[/* index */1]), spaceChars)) {
      _input = /* record */[
        /* text */input$1[/* text */0],
        /* index */input$1[/* index */1] + 1 | 0,
        /* whitespace */input$1[/* whitespace */2]
      ];
      continue ;
      
    } else {
      return input$1;
    }
  };
}

function charParser(c, rawInput) {
  var input = skipWhitespace(rawInput[/* whitespace */2], rawInput);
  var match = +(input[/* text */0].length <= input[/* index */1]);
  if (match !== 0) {
    return /* ParseFailure */Block.__(1, [
              "no more length",
              input
            ]);
  } else {
    var firstChar = Caml_string.get(input[/* text */0], input[/* index */1]);
    var match$1 = +(firstChar === c);
    if (match$1 !== 0) {
      return /* ParseSuccess */Block.__(0, [
                c,
                /* record */[
                  /* text */input[/* text */0],
                  /* index */input[/* index */1] + 1 | 0,
                  /* whitespace */input[/* whitespace */2]
                ]
              ]);
    } else {
      return /* ParseFailure */Block.__(1, [
                "different char '" + (Char.escaped(firstChar) + ("' found, expected: '" + (Char.escaped(c) + "'"))),
                input
              ]);
    }
  }
}

function chr(c) {
  return (function (param) {
      return charParser(c, param);
    });
}

function stringParser(s, rawInput) {
  var input = skipWhitespace(rawInput[/* whitespace */2], rawInput);
  var match = +((input[/* text */0].length - input[/* index */1] | 0) < s.length);
  if (match !== 0) {
    return /* ParseFailure */Block.__(1, [
              "no more length",
              input
            ]);
  } else {
    var substr = $$String.sub(input[/* text */0], input[/* index */1], s.length);
    var match$1 = +(substr === s);
    if (match$1 !== 0) {
      return /* ParseSuccess */Block.__(0, [
                s,
                /* record */[
                  /* text */input[/* text */0],
                  /* index */input[/* index */1] + s.length | 0,
                  /* whitespace */input[/* whitespace */2]
                ]
              ]);
    } else {
      return /* ParseFailure */Block.__(1, [
                "remined text doesn't start with " + s,
                input
              ]);
    }
  }
}

function str(s) {
  return (function (param) {
      return stringParser(s, param);
    });
}

exports.parse            = parse;
exports.andThen          = andThen;
exports.$less$star$great = $less$star$great;
exports.onlyLeft         = onlyLeft;
exports.$less$star       = $less$star;
exports.onlyRight        = onlyRight;
exports.$star$great      = $star$great;
exports.orElse           = orElse;
exports.$less$pipe$great = $less$pipe$great;
exports.rep              = rep;
exports.rep1             = rep1;
exports.optional         = optional;
exports.opt              = opt;
exports.andPred          = andPred;
exports.notPred          = notPred;
exports.into             = into;
exports.$great$great     = $great$great;
exports.skipWhitespace   = skipWhitespace;
exports.charParser       = charParser;
exports.chr              = chr;
exports.stringParser     = stringParser;
exports.str              = str;
/* No side effect */
